% This simulation reproduces the fmri-based motion direction reconstruction
% analysis step-by-step. It's written in the form of a tutorial and it's
% divided in 3 parts: data generation, voxel-wise GPR estimation, searchlight 
% based stimulus reconstruction.
%
%Written By Joram Soch & Riccardo Barbieri.
%Other Contributors: Felix Toepfer, Carsten Bogler.
clear all
GPR_ML_path = %path to GPR_ML_library http://gaussianprocess.org/gpml/code/matlab/doc/
addpath(genpath('functions/'))
addpath(genpath(GPR_ML_path));
plotit = 1;
rng = 1;
%-------------------------------------------------------------------------%
%% Part 1: Data generation

% For the fmri-based analysis the independent variable x is the motion
% direction shown to the participants or the direction of motion that
% participants reported to perceived. The dependent variable is the BOLD
% signal estimated via trial-wise first-level GLM and extracted from beta
% images. For this example we generate x by randomly drawing a value from
% the indepenent variable space x0 for each trial, for every run.
% The dependent variable is generated by simulating a certain number of
% voxels having their activity modulated by x0. Each voxel has its own response
% profile (tuning) which is constrained by few assumptions.

%------------------------% Data properties %------------------------------%

% specify data dimensions

t = 16;                           %number of trials
v = 10;                           %number of voxels
S = 10;                           %number of runs
VpSL = 5;                         %number of voxels per searchlight

% specify signal properties
s2 = 5;                               % noise variance
L = 0.5;                                % smoothness of the periodic Kernel

prec = 1;                             %precision of x0 samplig (in degrees)

%------------------------% Data generation %------------------------------%

x0 = [(prec/180)*pi:(prec/180)*pi:2*pi]'; %x0 is the space of independent
                                          %variable i.e. all of the possible
                                          %motion directions

Yt = zeros(numel(x0),v);                  %Yt is the dependent variable
                                          %i.e. voxel activity

for i = 1:v                               %In this example we simulate the
    K = ME_GPR_kern(x0, x0, 'per', L);    %relationship between Yt and x0
    Yt(:,i) = mvnrnd(zeros(size(x0)), K); %to follow a sinus periodic kernel
                                          %with smoothness = L (see ME_GPR_kern)
end

%labels are randomly generated by sampling values of the indepentent variable
%(for convenience we keep it in degrees during this phase)
labels = zeros(t,S);

for k = 1:S
    labels(:,k) = rad2deg(x0(randi(size(x0,1),t,1)));
end

E = normrnd(0, sqrt(s2), [t,v,S]);   %E is the matrix of simulated variance

yt = zeros(t,v,S);

% for each label we sample the corresponding simulated signal with some
% variance added.

for c = 1:t
    for i = 1:v
        for j = 1:S
            yt(c,i,j) = Yt(ceil(labels(c,j)),i)+E(c,i,j);
        end
    end
end

if plotit
    plot_raw(yt,labels)
end

%% Part 2: Perform voxel-wise GPR estimation

% The goal of this part is to obtain a continuous estimate of the change in
% voxels activity (Y) as a function of motion direction (x).

% The model follows the assumption that neuronal populations in a voxel
% sensitive to motion direction, will be preferentially tuned to one
% (or multiple) specific directions but not to other, displaying a smooth
% response profile. However, our experimental design will only include a
% limited number of sampled directions and voxel activities.
% GPR fills the by exploiting the covariance matrix (kernel) of each voxel
% across trials (see covPeriodic_RDM for details on the covariance function).
% This allow to obtain an estimate of the voxel's mean response profile (mup),
% its variance s2x, and the kernel's hyperparameters (hyp), which will be
% then used to perform the motion direction reconstruction.

%------------------------% Analysis setup %-------------------------------%

m  = numel(x0);                     % number of possible motion directions

%preallocate outcome variables
mup = zeros(m,v,S);                 % predicted continuous voxel response
mux = zeros(t*(S-1),v,S);           % fitted trial-wise voxel response
s2x = zeros(S,v);                   % voxels variance
hyp(S,v) = struct('mean',...
    [], 'cov', [0], 'lik', -1);     % voxels Kernel hyperparameters

%------------------------% Voxel-wise GPR %-------------------------------%
fprintf('\n\n-> Voxel-wise GPR:\n');
parfor ii = 1:v
       
    fprintf('   - voxel number %02d ...\n ', ii);
    
    vv = squeeze(yt(:,ii,:));
    
    for r = 1:S
        
        %training index for current cv fold
        itrain =  [1:S] ~= r;
        
        %vectorize data for current cv fold
        vectors_train = vv(:,itrain)';
        Samples = vectors_train(:);
        
        labels_train = labels(:,itrain)';
        Labels = labels_train(:)./360*2*pi;     %Labels are converted in rad
        
        % cyclic multivariate Gaussian process regression
        
        [mup(:,ii,r), mux(:,ii,r), s2x(r,ii), hyp(r,ii)] = ME_cmGPR_mean(Samples, Labels,x0);
        
    end    
end
%% Part 3: Perform searchlight based stimulus reconstruction

% Now we can use the response profiles (mup) to perform direction
% reconstruction via MLE. We first combine multiple response profiles
% within a searchlight (mup_SL). We then estimate the searchlight spatial
% covariance (S2_est - see ME_cmGPR_cov) and compute the Log PDF of the
% multivariate normal distribution with means = mup_SL and covariance = S2_est
% (see logmvnpdf). The predicted motion direction will be the one maximizing
% the log-liklehood given the current data and response profiles in a SL.
% This procedure is performed in a run-wise cv procedure. Finally we calculate
% the absolute angular deviation between the true and the predicted direction
% to compute a crossvalidated continuous accuracy measure (see
% avg_norm_circ_resp_dev and bal_norm_circ_resp_dev).

%------------------------% Analysis setup %-------------------------------%
% define searchlights

SL = zeros(v-VpSL+1,VpSL);
for k = 1:size(SL,1)
    SL(k,:) = [k:(k+VpSL-1)];
end

%preallocate outcome variables

acc_vol = zeros(size(SL,1), 1);           % SL cross-validated accuracy
bal_acc_vol = zeros(size(SL,1), 1);       % SL balanced cross-validated accuracy
predicted_directions = cell(size(SL,1),S);% SL trial-wise predicted direction
true_directions = cell(S,1);              % tesing lables of each cv-fold

%-----------------% SL-based stimulus reconstruction %--------------------%
fprintf('\n\n-> SL-based reconstruction:\n');
for ii = 1:size(SL,1)
     fprintf('   - SL number %02d ...\n ', ii);
    
    % Bring only data from the current searchlight into the loop
    
    vv_sl = yt(:,SL(ii,:),:);       % trial-wise betas
    hyp_sl = hyp(:,SL(ii,:));       % voxel-wise kernel hyperparameters
    mup_sl = mup(:,SL(ii,:),:);     % predicted continuous voxel response
    mux_sl = mux(:,SL(ii,:),:);     % fitted trial-wise voxel response
    s2x_sl = s2x(:,SL(ii,:));       % voxels variance
    n_sl_vox = numel(SL(ii,:));     % number of voxels in the sl
    
    for r = 1:S
        
        %training and testing index for current cv fold
        itrain = find( [1:S] ~= r);
        itest  = r;
        
        %vectorize training data for current cv fold
        vectors_train = vv_sl(:,:,itrain);
        train_samples = permute(vectors_train,[3,1,2]);
        train_samples = reshape(train_samples,[t*(S-1),n_sl_vox]);
        
        labels_train = labels(:,itrain)';
        labels_train = labels_train(:)./360*2*pi;     %Labels are converted in rad
        
        %vectorize testing data for current cv fold
        
        test_samples = vv_sl(:,:,itest);
        labels_test = labels(:,itest);
        labels_test = labels_test./360*2*pi;     %Labels are converted in rad
        
        % cyclic multivariate Gaussian process regression
        
        % estimate spatial covariance in sl
        S2_est = ME_cmGPR_cov(train_samples, mux_sl(:,:,r), s2x_sl(r,:), 'logistic');
        
        % reconstruct direction from sl activity
        predicted_directions{ii,r} = ME_cmGPR_pred(test_samples, x0, mup_sl(:,:,r), S2_est);
        true_directions{r} = labels_test;
        
    end
    
    % quantify crossvalidated accuracy and balanced crossvalidated
    % accuracy
    current_predictions = [predicted_directions{ii,1:end}]';
    current_true_dir =[true_directions{1:end}]';
    acc_vol(ii) = avg_norm_circ_resp_dev(current_predictions(:),current_true_dir(:));
    bal_acc_vol(ii)= bal_norm_circ_resp_dev(current_predictions(:),current_true_dir(:),'trapz');
    
    acc_vol(ii) = acc_vol(ii)*100;
    bal_acc_vol(ii) =  bal_acc_vol(ii)*100;
     
    fprintf('successful!\n');
    
end

if plotit
    plot_fit(yt,labels,mup,1,[1:10],'2d')
    plot_fit(yt,labels,mup,1,[1:10],'3d')
    dx = plot_reconstruction(predicted_directions,true_directions,10);
end


