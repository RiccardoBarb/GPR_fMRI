%% This script is written to perform statistical analysis on information 
%% reconstructed using the gpr reconstruction approach applied on time-
%% continous data.

% This script is a merge between a script by Joram Soch to estimate
% balanced accuracy from gpr based reconstructions and a script by Gi-Yeul
% Bae to constructs null distribution of t-mass for clusters of significant time points 
% by randomly shuffling target labels multiple times (1000 times).
% Bae, Gi-Yeul, and Steven J. Luck. "Decoding motion direction using the topography of sustained ERPs and alpha oscillations." NeuroImage 184 (2019): 242-255.
% All credits go to these authors

% Written Felix M TÃ¶pfer 15112020
% last edit 26012021


%% define paths get datafiles of interest
clear; clc; close all;

% add the current path, because this is your working directory
thispath=pwd;
addpath(genpath(thispath));
addpath(genpath('../functions'));


% get paths
data_dir='../../data/eye_tracking_for_GPR';
search_index='s3';
folder_dir=get_data_folder_directory(data_dir,search_index);


for f_=1:numel(folder_dir)
    data_direct=folder_dir{f_};
    search_index='gpr';
    folder_dir(f_)=get_data_folder_directory(data_direct,search_index);
end
     
%% define variables

rng='shuffle';                      % shuffle random number generator
labels = {'stimulus','report'};     % which labels to analyse
coh = {'low','mid','high'};         % define coherence levels
tp=101;                             % number of time points of interest
simulations=1000;                   % number of simulations

t = 16;                             %number of trials
S = 10;                             %number of runs
prec = 1;                           %precision of x0 samplig (in degrees)
x0 = [(prec/180)*pi:(prec/180)*pi:2*pi]'; %x0 is the space of independent variable i.e. all of the possible motion directions
%labels are randomly generated by sampling values of the indepentent variable
%(for convenience we keep it in degrees during this phase)


%% analysis

for lab_=1:numel(labels)                        % for every label
    
    search_str=labels{lab_};                    % find files of interest
    file_extension=[labels{lab_} '.mat'];
    [files_dir, subj_name]=get_files_directory(folder_dir,search_str,file_extension);
    
    for coh_ = 1:numel(coh)                     % for every coherence
        
        
        simulationT = nan(1,simulations);       % run 1000 simulations
        for sim_=1:simulations
            tic
            disp(['Eye' '   |   ' coh(coh_) '   |   '  labels{lab_} '   |   ' num2str(sim_)])

            bal_acc_smooth=nan(numel(files_dir),tp);
            
            for subj_=1:numel(files_dir)
                load(files_dir{subj_})
                
                bal_acc_subj=nan(1,tp);
                for tp_=1:tp
                    
                %generate random directions
                    random_directions = zeros(S,t); %trialsxruns
                    for k = 1:S
                        random_directions(k,:) = x0(randi(size(x0,1),t,1));
                    end
                    
                %get predicted directions    
                    predicted_directions=squeeze(pred_direct(coh_,tp_,:,:));
                     
                    bal_acc_subj(tp_)= bal_norm_circ_resp_dev(predicted_directions(:),random_directions(:),'trapz');
                    
                end
                
                bal_acc_smooth(subj_,:)=smooth(bal_acc_subj,5);
            end
            
            % get average and se from all subjects
                bal_acc_subj_ave=squeeze(nanmean(bal_acc_smooth,1));
                bal_acc_subj_se=squeeze(nanstd(bal_acc_smooth,1))/sqrt(numel(files_dir));
            
            % cluster analysis
                Ps = nan(2,tp);
                for tp_ = 1:tp 
    %                 tp = releventTime(i);

                    [H,P,CI,STATS] =  ttest(bal_acc_smooth(:,tp_), 0.5,'tail','right'); % Test Against Zero

                    Ps(1,tp_) = STATS.tstat;
                    Ps(2,tp_) = P;
                end
                % find significant points
                candid = Ps(2,:) <= .05;

                candid_marked = zeros(1,length(candid));
                candid_marked(1,1) = candid(1,1); % the first entry is just plugged in because the later for loop (line 163) starts with the 2nd entry
                candid_marked(1,length(candid)) = candid(1,length(candid));% the last entry is just plugged because the for loop ends at end-1
                %remove orphan time points
                for i = 2:tp-1
                    if candid(1,i-1) == 0 && candid(1,i) ==1 && candid(1,i+1) ==0
                    candid_marked(1,i) = 0; 
                    else
                    candid_marked(1,i) = candid(1,i);     
                    end
                end
            
            
                % combine whole time range with relevent time & significant information
                clusters = zeros(tp,1);
                clusterT = zeros(tp,1);
                clusters(:,1) = candid_marked;
                clusterT(:,1) = Ps(1,:);
                clusterTsum = sum(Ps(1,logical(candid_marked))); % sum of T-Stats for significant clusters

                %%find how many clusters are there, and compute summed T of each cluster
                tmp = zeros(10,25);
                cl = 0;
                member = 0;
                for i = 2:length(clusters)-1

                    if clusters(i-1) ==0 && clusters(i) == 1 && clusters(i+1) == 1 % if it's the first of a cluster
                    cl = cl+1;
                    member = member +1;
                    tmp(cl,member) = i;    

                    elseif clusters(i-1) ==1 && clusters(i) == 1 && clusters(i+1) == 0 % if it's the last of a cluster
                    member = member +1;  
                    if cl == 0
                        cl = cl+1; % in case first index in clusters equals 1
                    end
                    tmp(cl,member) = i;    
                    member = 0;  
                    elseif clusters(i-1) ==1 && clusters(i) == 1 && clusters(i+1) == 1 % if it's in the middle             
                    member = member +1;  
                    if cl == 0
                        cl = cl+1; % in case first index in clusters equals 1
                    end
                    tmp(cl,member) = i;    

                    else % if it's not part of a cluster move on

                    end
                end


                HowManyClusters = cl;
                a = tmp(1:cl,:);
                eachCluster = a(:,logical(sum(a,1)~=0));

                %now, compute summed T of each cluster 
                dat_clusterSumT = zeros(HowManyClusters,1);
                for c = 1:HowManyClusters
                    dat_clusterSumT(c,1) = sum(clusterT(eachCluster(c,eachCluster(c,:) ~=0)));
                end

                if size(dat_clusterSumT,1) > 0
                    simulationT(1,sim_) = max(dat_clusterSumT);
                else
                    simulationT(1,sim_) = 0;     
                end
     
        end
        %sort values
        simulationT = sort(simulationT);
        
        % save values
        fname = [data_dir, filesep, 'permutation_test', filesep, 'GPR_simulation_' coh{coh_} '_' labels{lab_} '.mat'];
        save(fname,'simulationT')
        toc
    end
end